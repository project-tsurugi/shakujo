subprojects {
  apply plugin: 'java'
  apply plugin: 'eclipse'

  plugins.withId('java') {
    project.sourceCompatibility = JavaVersion.toVersion('10')
    project.targetCompatibility = project.sourceCompatibility

    tasks.withType(JavaCompile) { task ->
        task.options.encoding = 'UTF-8'
    }

    repositories {
      mavenCentral()
    }

    dependencies {
      // compile 'javax.annotation:javax.annotation-api:1.3.2'
      implementation 'com.google.guava:guava:25.0-jre'
      testImplementation 'org.junit.jupiter:junit-jupiter-api:5+'
      testImplementation 'org.junit.jupiter:junit-jupiter-params:5+'
      testImplementation 'org.junit.jupiter:junit-jupiter-engine:5+'

      // for eclipse
      testImplementation "org.junit.platform:junit-platform-launcher:1+"
    }

    configurations.all {
      resolutionStrategy {
        dependencySubstitution {
          // substitute module("javax.annotation:jsr250-api") with module("javax.annotation:javax.annotation-api:1.3.2")
          // substitute module("javax.annotation:jsr305") with module("javax.annotation:javax.annotation-api:1.3.2")
          // substitute module("com.google.code.findbugs:jsr305") with module("javax.annotation:javax.annotation-api:1.3.2")
        }
      }
    }

    task sourcesJar(type: Jar) {
        classifier 'sources'
        from sourceSets.main.allSource
    }

    task testsJar(type: Jar) {
        classifier 'tests'
        from sourceSets.test.output
    }

    artifacts {
        archives tasks.sourcesJar
        archives tasks.testsJar
    }

    plugins.withId('eclipse') {
      eclipse {
        project {
          name "${rootProject.name}-${project.name}"
        }
        classpath {
        }
        jdt {
          javaRuntimeName "JavaSE-${sourceCompatibility.majorVersion}"
        }
      }
    }
  }
}

task generate(group: "application", type: Copy, dependsOn: ":sql:run") {
  into("../../model")
  from(project(":sql").file("build/cpp")) {
    include "**/*.h"
    include "**/*.cpp" // FIXME flatten
    exclude "**/.*"
    includeEmptyDirs false
    eachFile { f ->
      if (f.relativePath.isFile()) {
        def segments = f.relativePath.segments as List
        if (segments[0] == "src") {
          for (def iter = segments.listIterator(1); iter.hasNext();) {
            def s = iter.next()
            iter.remove()
            if (s == "model") {
              break;
            }
          }
          f.setPath(segments.join("/"))
        }
      }

      def src = f.file
      def dst = new File(destinationDir, f.path)
      if (dst.isFile() && src.bytes == dst.bytes) {
        f.duplicatesStrategy = DuplicatesStrategy.EXCLUDE
      }
    }
  }
}
